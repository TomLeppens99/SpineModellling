/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace OpenSim {

using System;
using System.Runtime.InteropServices;

public class InverseKinematicsSolver : AssemblySolver {
  private HandleRef swigCPtr;

  internal InverseKinematicsSolver(IntPtr cPtr, bool cMemoryOwn) : base(CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new HandleRef(this, cPtr);
  }

  internal static HandleRef getCPtr(InverseKinematicsSolver obj) {
    return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
  }

  ~InverseKinematicsSolver() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          CSharpWrapOpenSimPINVOKE.delete_InverseKinematicsSolver(swigCPtr);
        }
        swigCPtr = new HandleRef(null, IntPtr.Zero);
      }
      GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

  public unsafe InverseKinematicsSolver(Model model, MarkersReference markersReference, ArrayCoordinateReference coordinateReferences, double constraintWeight) : this(CSharpWrapOpenSimPINVOKE.new_InverseKinematicsSolver__SWIG_0(Model.getCPtr(model), MarkersReference.getCPtr(markersReference), ArrayCoordinateReference.getCPtr(coordinateReferences), constraintWeight), true) {
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe InverseKinematicsSolver(Model model, MarkersReference markersReference, ArrayCoordinateReference coordinateReferences) : this(CSharpWrapOpenSimPINVOKE.new_InverseKinematicsSolver__SWIG_1(Model.getCPtr(model), MarkersReference.getCPtr(markersReference), ArrayCoordinateReference.getCPtr(coordinateReferences)), true) {
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe void updateMarkerWeight(string markerName, double value) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_updateMarkerWeight__SWIG_0(swigCPtr, markerName, value);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe void updateMarkerWeight(int markerIndex, double value) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_updateMarkerWeight__SWIG_1(swigCPtr, markerIndex, value);
  }

  public unsafe void updateMarkerWeights(SimTKArrayDouble weights) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_updateMarkerWeights(swigCPtr, SimTKArrayDouble.getCPtr(weights));
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe Vec3 computeCurrentMarkerLocation(string markerName) {
    Vec3 ret = new Vec3(CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerLocation__SWIG_0(swigCPtr, markerName), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe Vec3 computeCurrentMarkerLocation(int markerIndex) {
    Vec3 ret = new Vec3(CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerLocation__SWIG_1(swigCPtr, markerIndex), true);
    return ret;
  }

  public unsafe void computeCurrentMarkerLocations(SimTKArrayVec3 markerLocations) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerLocations(swigCPtr, SimTKArrayVec3.getCPtr(markerLocations));
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe double computeCurrentMarkerError(string markerName) {
    double ret = CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerError__SWIG_0(swigCPtr, markerName);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe double computeCurrentMarkerError(int markerIndex) {
    double ret = CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerError__SWIG_1(swigCPtr, markerIndex);
    return ret;
  }

  public unsafe void computeCurrentMarkerErrors(SimTKArrayDouble markerErrors) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentMarkerErrors(swigCPtr, SimTKArrayDouble.getCPtr(markerErrors));
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe double computeCurrentSquaredMarkerError(string markerName) {
    double ret = CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentSquaredMarkerError__SWIG_0(swigCPtr, markerName);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe double computeCurrentSquaredMarkerError(int markerIndex) {
    double ret = CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentSquaredMarkerError__SWIG_1(swigCPtr, markerIndex);
    return ret;
  }

  public unsafe void computeCurrentSquaredMarkerErrors(SimTKArrayDouble markerErrors) {
    CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_computeCurrentSquaredMarkerErrors(swigCPtr, SimTKArrayDouble.getCPtr(markerErrors));
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
  }

  public unsafe string getMarkerNameForIndex(int markerIndex) {
    string ret = CSharpWrapOpenSimPINVOKE.InverseKinematicsSolver_getMarkerNameForIndex(swigCPtr, markerIndex);
    return ret;
  }

}

}
