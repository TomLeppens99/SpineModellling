/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace OpenSim {

using System;
using System.Runtime.InteropServices;

public class CSharpWrapOpenSim {
  public unsafe static SpatialVec findRelativeVelocity(SWIGTYPE_p_Transform X_FA, SpatialVec V_FA, SWIGTYPE_p_Transform X_FB, SpatialVec V_FB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.findRelativeVelocity(SWIGTYPE_p_Transform.getCPtr(X_FA), SpatialVec.getCPtr(V_FA), SWIGTYPE_p_Transform.getCPtr(X_FB), SpatialVec.getCPtr(V_FB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec findRelativeVelocityInF(Vec3 p_AB_F, SpatialVec V_FA, SpatialVec V_FB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.findRelativeVelocityInF(Vec3.getCPtr(p_AB_F), SpatialVec.getCPtr(V_FA), SpatialVec.getCPtr(V_FB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec findRelativeAcceleration(SWIGTYPE_p_Transform X_FA, SpatialVec V_FA, SpatialVec A_FA, SWIGTYPE_p_Transform X_FB, SpatialVec V_FB, SpatialVec A_FB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.findRelativeAcceleration(SWIGTYPE_p_Transform.getCPtr(X_FA), SpatialVec.getCPtr(V_FA), SpatialVec.getCPtr(A_FA), SWIGTYPE_p_Transform.getCPtr(X_FB), SpatialVec.getCPtr(V_FB), SpatialVec.getCPtr(A_FB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec findRelativeAccelerationInF(Vec3 p_AB_F, SpatialVec V_FA, SpatialVec A_FA, SpatialVec V_FB, SpatialVec A_FB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.findRelativeAccelerationInF(Vec3.getCPtr(p_AB_F), SpatialVec.getCPtr(V_FA), SpatialVec.getCPtr(A_FA), SpatialVec.getCPtr(V_FB), SpatialVec.getCPtr(A_FB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec reverseRelativeVelocity(SWIGTYPE_p_Transform X_AB, SpatialVec V_AB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.reverseRelativeVelocity(SWIGTYPE_p_Transform.getCPtr(X_AB), SpatialVec.getCPtr(V_AB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec reverseRelativeVelocityInA(SWIGTYPE_p_Transform X_AB, SpatialVec V_AB) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.reverseRelativeVelocityInA(SWIGTYPE_p_Transform.getCPtr(X_AB), SpatialVec.getCPtr(V_AB)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftVelocityBy(SpatialVec V_AB, Vec3 r_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftVelocityBy(SpatialVec.getCPtr(V_AB), Vec3.getCPtr(r_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftVelocityFromTo(SpatialVec V_A_BP, Vec3 fromP_A, Vec3 toQ_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftVelocityFromTo(SpatialVec.getCPtr(V_A_BP), Vec3.getCPtr(fromP_A), Vec3.getCPtr(toQ_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftForceBy(SpatialVec F_AP, Vec3 r_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftForceBy(SpatialVec.getCPtr(F_AP), Vec3.getCPtr(r_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftForceFromTo(SpatialVec F_AP, Vec3 fromP_A, Vec3 toQ_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftForceFromTo(SpatialVec.getCPtr(F_AP), Vec3.getCPtr(fromP_A), Vec3.getCPtr(toQ_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftAccelerationBy(SpatialVec A_AB, Vec3 w_AB, Vec3 r_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftAccelerationBy(SpatialVec.getCPtr(A_AB), Vec3.getCPtr(w_AB), Vec3.getCPtr(r_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static SpatialVec shiftAccelerationFromTo(SpatialVec A_A_BP, Vec3 w_AB, Vec3 fromP_A, Vec3 toQ_A) {
    SpatialVec ret = new SpatialVec(CSharpWrapOpenSimPINVOKE.shiftAccelerationFromTo(SpatialVec.getCPtr(A_A_BP), Vec3.getCPtr(w_AB), Vec3.getCPtr(fromP_A), Vec3.getCPtr(toQ_A)), true);
    if (CSharpWrapOpenSimPINVOKE.SWIGPendingException.Pending) throw CSharpWrapOpenSimPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public unsafe static void SimTK_version_SimTKcommon(SWIGTYPE_p_int major, SWIGTYPE_p_int minor, SWIGTYPE_p_int build) {
    CSharpWrapOpenSimPINVOKE.SimTK_version_SimTKcommon(SWIGTYPE_p_int.getCPtr(major), SWIGTYPE_p_int.getCPtr(minor), SWIGTYPE_p_int.getCPtr(build));
  }

  public unsafe static void SimTK_about_SimTKcommon(string key, int maxlen, string value) {
    CSharpWrapOpenSimPINVOKE.SimTK_about_SimTKcommon(key, maxlen, value);
  }

  public unsafe static bool canStoreInNonnegativeInt(bool arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_0(arg0);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(char c) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_1(c);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(byte arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_2(arg0);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(sbyte c) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_3(c);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(short s) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_4(s);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(ushort arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_5(arg0);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(int i) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_6(i);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(long l) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_8(l);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(uint u) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_9(u);
    return ret;
  }

  public unsafe static bool canStoreInNonnegativeInt(ulong u) {
    bool ret = CSharpWrapOpenSimPINVOKE.canStoreInNonnegativeInt__SWIG_11(u);
    return ret;
  }

  public unsafe static bool isSizeInRange(char sz, char mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_0(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(sbyte sz, sbyte mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_1(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(short sz, short mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_2(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(int sz, int mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_3(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(long sz, long mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_5(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(byte sz, byte mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_6(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(ushort sz, ushort mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_7(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(uint sz, uint mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_8(sz, mx);
    return ret;
  }

  public unsafe static bool isSizeInRange(ulong sz, ulong mx) {
    bool ret = CSharpWrapOpenSimPINVOKE.isSizeInRange__SWIG_10(sz, mx);
    return ret;
  }

  public unsafe static bool isIndexInRange(char ix, char sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_0(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(sbyte ix, sbyte sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_1(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(short ix, short sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_2(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(int ix, int sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_3(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(long ix, long sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_5(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(byte ix, byte sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_6(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(ushort ix, ushort sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_7(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(uint ix, uint sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_8(ix, sz);
    return ret;
  }

  public unsafe static bool isIndexInRange(ulong ix, ulong sz) {
    bool ret = CSharpWrapOpenSimPINVOKE.isIndexInRange__SWIG_10(ix, sz);
    return ret;
  }

  public unsafe static bool isNonnegative(bool arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_0(arg0);
    return ret;
  }

  public unsafe static bool isNonnegative(char n) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_1(n);
    return ret;
  }

  public unsafe static bool isNonnegative(sbyte n) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_2(n);
    return ret;
  }

  public unsafe static bool isNonnegative(short n) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_3(n);
    return ret;
  }

  public unsafe static bool isNonnegative(int n) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_4(n);
    return ret;
  }

  public unsafe static bool isNonnegative(long n) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_6(n);
    return ret;
  }

  public unsafe static bool isNonnegative(byte arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_7(arg0);
    return ret;
  }

  public unsafe static bool isNonnegative(ushort arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_8(arg0);
    return ret;
  }

  public unsafe static bool isNonnegative(uint arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_9(arg0);
    return ret;
  }

  public unsafe static bool isNonnegative(ulong arg0) {
    bool ret = CSharpWrapOpenSimPINVOKE.isNonnegative__SWIG_11(arg0);
    return ret;
  }

  public unsafe static int InvalidIndex {
    get {
      int ret = CSharpWrapOpenSimPINVOKE.InvalidIndex_get();
      return ret;
    } 
  }

  public unsafe static Vec3 Black {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Black_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Gray {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Gray_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Red {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Red_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Green {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Green_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Blue {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Blue_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Yellow {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Yellow_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Orange {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Orange_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Magenta {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Magenta_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Purple {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Purple_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 Cyan {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.Cyan_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static Vec3 White {
    get {
      IntPtr cPtr = CSharpWrapOpenSimPINVOKE.White_get();
      Vec3 ret = (cPtr == IntPtr.Zero) ? null : new Vec3(cPtr, false);
      return ret;
    } 
  }

  public unsafe static int Array_CAPMIN {
    get {
      int ret = CSharpWrapOpenSimPINVOKE.Array_CAPMIN_get();
      return ret;
    } 
  }

  public unsafe static string ObjectDEFAULT_NAME {
    get {
      string ret = CSharpWrapOpenSimPINVOKE.ObjectDEFAULT_NAME_get();
      return ret;
    } 
  }

  public unsafe static int IO_STRLEN {
    get {
      int ret = CSharpWrapOpenSimPINVOKE.IO_STRLEN_get();
      return ret;
    } 
  }

  public unsafe static int PointKinematicsNAME_LENGTH {
    get {
      int ret = CSharpWrapOpenSimPINVOKE.PointKinematicsNAME_LENGTH_get();
      return ret;
    } 
  }

  public unsafe static int PointKinematicsBUFFER_LENGTH {
    get {
      int ret = CSharpWrapOpenSimPINVOKE.PointKinematicsBUFFER_LENGTH_get();
      return ret;
    } 
  }

  public unsafe static bool mapCxxExceptionsToJava {
    set {
      CSharpWrapOpenSimPINVOKE.mapCxxExceptionsToJava_set(value);
    } 
    get {
      bool ret = CSharpWrapOpenSimPINVOKE.mapCxxExceptionsToJava_get();
      return ret;
    } 
  }

  public unsafe static readonly double SimTK_PI = CSharpWrapOpenSimPINVOKE.SimTK_PI_get();
  public unsafe static readonly double SimTK_E = CSharpWrapOpenSimPINVOKE.SimTK_E_get();
  public unsafe static readonly double SimTK_LN2 = CSharpWrapOpenSimPINVOKE.SimTK_LN2_get();
  public unsafe static readonly double SimTK_LN10 = CSharpWrapOpenSimPINVOKE.SimTK_LN10_get();
  public unsafe static readonly double SimTK_LOG2E = CSharpWrapOpenSimPINVOKE.SimTK_LOG2E_get();
  public unsafe static readonly double SimTK_LOG10E = CSharpWrapOpenSimPINVOKE.SimTK_LOG10E_get();
  public unsafe static readonly double SimTK_SQRT2 = CSharpWrapOpenSimPINVOKE.SimTK_SQRT2_get();
  public unsafe static readonly double SimTK_OOSQRT2 = CSharpWrapOpenSimPINVOKE.SimTK_OOSQRT2_get();
  public unsafe static readonly double SimTK_CBRT2 = CSharpWrapOpenSimPINVOKE.SimTK_CBRT2_get();
  public unsafe static readonly double SimTK_OOCBRT2 = CSharpWrapOpenSimPINVOKE.SimTK_OOCBRT2_get();
  public unsafe static readonly double SimTK_SIXRT2 = CSharpWrapOpenSimPINVOKE.SimTK_SIXRT2_get();
  public unsafe static readonly double SimTK_OOSIXRT2 = CSharpWrapOpenSimPINVOKE.SimTK_OOSIXRT2_get();
  public unsafe static readonly double SimTK_SQRT3 = CSharpWrapOpenSimPINVOKE.SimTK_SQRT3_get();
  public unsafe static readonly double SimTK_CBRT3 = CSharpWrapOpenSimPINVOKE.SimTK_CBRT3_get();
  public unsafe static readonly double SimTK_AVOGADROS_NUMBER = CSharpWrapOpenSimPINVOKE.SimTK_AVOGADROS_NUMBER_get();
  public unsafe static readonly double SimTK_MASS_OF_PROTON_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_MASS_OF_PROTON_IN_MD_get();
  public unsafe static readonly double SimTK_MASS_OF_NEUTRON_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_MASS_OF_NEUTRON_IN_MD_get();
  public unsafe static readonly double SimTK_MASS_OF_ELECTRON_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_MASS_OF_ELECTRON_IN_MD_get();
  public unsafe static readonly double SimTK_CHARGE_OF_PROTON_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_CHARGE_OF_PROTON_IN_SI_get();
  public unsafe static readonly double SimTK_CHARGE_OF_PROTON_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_CHARGE_OF_PROTON_IN_MD_get();
  public unsafe static readonly double SimTK_MOLAR_CHARGE_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_MOLAR_CHARGE_IN_SI_get();
  public unsafe static readonly double SimTK_MOLAR_CHARGE_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_MOLAR_CHARGE_IN_MD_get();
  public unsafe static readonly double SimTK_LIGHTSPEED_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_LIGHTSPEED_IN_SI_get();
  public unsafe static readonly double SimTK_LIGHTSPEED_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_LIGHTSPEED_IN_MD_get();
  public unsafe static readonly double SimTK_GRAVITATIONAL_CONSTANT_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_GRAVITATIONAL_CONSTANT_IN_SI_get();
  public unsafe static readonly double SimTK_GRAVITATIONAL_CONSTANT_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_GRAVITATIONAL_CONSTANT_IN_MD_get();
  public unsafe static readonly double SimTK_MAGNETIC_PERMEABILITY_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_MAGNETIC_PERMEABILITY_IN_SI_get();
  public unsafe static readonly double SimTK_MAGNETIC_PERMEABILITY_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_MAGNETIC_PERMEABILITY_IN_MD_get();
  public unsafe static readonly double SimTK_ELECTRIC_PERMITTIVITY_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_ELECTRIC_PERMITTIVITY_IN_SI_get();
  public unsafe static readonly double SimTK_ELECTRIC_PERMITTIVITY_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_ELECTRIC_PERMITTIVITY_IN_MD_get();
  public unsafe static readonly double SimTK_COULOMB_CONSTANT_IN_SI = CSharpWrapOpenSimPINVOKE.SimTK_COULOMB_CONSTANT_IN_SI_get();
  public unsafe static readonly double SimTK_COULOMB_CONSTANT_IN_MD = CSharpWrapOpenSimPINVOKE.SimTK_COULOMB_CONSTANT_IN_MD_get();
  public unsafe static readonly double SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM = CSharpWrapOpenSimPINVOKE.SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM_get();
  public unsafe static readonly double SimTK_MOLAR_GAS_CONSTANT_SI = CSharpWrapOpenSimPINVOKE.SimTK_MOLAR_GAS_CONSTANT_SI_get();
  public unsafe static readonly double SimTK_MOLAR_GAS_CONSTANT_MD = CSharpWrapOpenSimPINVOKE.SimTK_MOLAR_GAS_CONSTANT_MD_get();
  public unsafe static readonly double SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM = CSharpWrapOpenSimPINVOKE.SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM_get();
  public unsafe static readonly double SimTK_BOLTZMANN_CONSTANT_SI = CSharpWrapOpenSimPINVOKE.SimTK_BOLTZMANN_CONSTANT_SI_get();
  public unsafe static readonly double SimTK_BOLTZMANN_CONSTANT_MD = CSharpWrapOpenSimPINVOKE.SimTK_BOLTZMANN_CONSTANT_MD_get();
  public unsafe static readonly double SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM = CSharpWrapOpenSimPINVOKE.SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM_get();
  public unsafe static readonly double SimTK_RADIAN_TO_DEGREE = CSharpWrapOpenSimPINVOKE.SimTK_RADIAN_TO_DEGREE_get();
  public unsafe static readonly double SimTK_DEGREE_TO_RADIAN = CSharpWrapOpenSimPINVOKE.SimTK_DEGREE_TO_RADIAN_get();
  public unsafe static readonly double SimTK_NS_TO_S = CSharpWrapOpenSimPINVOKE.SimTK_NS_TO_S_get();
  public unsafe static readonly double SimTK_S_TO_NS = CSharpWrapOpenSimPINVOKE.SimTK_S_TO_NS_get();
  public unsafe static readonly double SimTK_KCAL_TO_KJOULE = CSharpWrapOpenSimPINVOKE.SimTK_KCAL_TO_KJOULE_get();
  public unsafe static readonly double SimTK_KJOULE_TO_KCAL = CSharpWrapOpenSimPINVOKE.SimTK_KJOULE_TO_KCAL_get();
  public unsafe static readonly double SimTK_DALTON_TO_GRAM = CSharpWrapOpenSimPINVOKE.SimTK_DALTON_TO_GRAM_get();
  public unsafe static readonly double SimTK_E_TO_COULOMB = CSharpWrapOpenSimPINVOKE.SimTK_E_TO_COULOMB_get();
  public unsafe static readonly double SimTK_EV_TO_JOULE = CSharpWrapOpenSimPINVOKE.SimTK_EV_TO_JOULE_get();
  public unsafe static readonly int SimTK_DEFAULT_PRECISION = CSharpWrapOpenSimPINVOKE.SimTK_DEFAULT_PRECISION_get();
}

}
